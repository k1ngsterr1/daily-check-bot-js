import { Injectable, Logger, forwardRef, Inject } from '@nestjs/common';
import { Cron, CronExpression, SchedulerRegistry } from '@nestjs/schedule';
import { PrismaService } from '../database/prisma.service';
import { TelegramBotService } from '../bot/telegram-bot.service';
import { HabitService } from './habit.service';
import * as cron from 'node-cron';

interface HabitReminder {
  habitId: string;
  userId: string;
  habitTitle: string;
  cronPattern: string;
  lastSent?: Date;
}

@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);
  private activeReminders: Map<string, cron.ScheduledTask> = new Map();

  constructor(
    private readonly prisma: PrismaService,
    @Inject(forwardRef(() => TelegramBotService))
    private readonly telegramBotService: TelegramBotService,
    private readonly habitService: HabitService,
    private readonly schedulerRegistry: SchedulerRegistry,
  ) {}

  async onModuleInit() {
    this.logger.log(
      'Notification service initialized (habit reminders disabled to avoid duplicates)',
    );
  }

  async loadActiveHabitReminders() {
    const activeHabits = await this.prisma.habit.findMany({
      where: {
        isActive: true,
        reminderTime: { not: null },
      },
      include: {
        user: true,
      },
    });

    for (const habit of activeHabits) {
      await this.scheduleHabitReminder(habit);
    }

    this.logger.log(`Loaded ${activeHabits.length} habit reminders`);
  }

  async scheduleHabitReminder(habit: any) {
    const cronPattern = this.parseReminderPattern(
      habit.reminderTime,
      habit.frequency,
    );

    if (!cronPattern) {
      this.logger.warn(
        `Could not parse reminder pattern for habit ${habit.id}`,
      );
      return;
    }

    const jobName = `habit_reminder_${habit.id}`;

    // –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ, –µ—Å–ª–∏ –µ—Å—Ç—å
    if (this.activeReminders.has(jobName)) {
      this.cancelHabitReminder(habit.id);
    }

    try {
      const task = cron.schedule(cronPattern, async () => {
        await this.sendHabitReminder(habit);
      });

      this.activeReminders.set(jobName, task);
      task.start();

      this.logger.log(
        `Scheduled reminder for habit "${habit.title}" with pattern: ${cronPattern}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to schedule reminder for habit ${habit.id}:`,
        error,
      );
    }
  }

  private parseReminderPattern(
    reminderTime: string,
    frequency: string,
  ): string | null {
    // –ü–∞—Ä—Å–∏–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –≤—Ä–µ–º–µ–Ω–∏
    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–π —á–∞—Å') ||
      reminderTime.includes('hourly')
    ) {
      return '0 * * * *'; // –ö–∞–∂–¥—ã–π —á–∞—Å –≤ –Ω–∞—á–∞–ª–µ —á–∞—Å–∞
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 2 —á–∞—Å–∞') ||
      reminderTime.includes('every 2 hours')
    ) {
      return '0 */2 * * *'; // –ö–∞–∂–¥—ã–µ 2 —á–∞—Å–∞
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 3 —á–∞—Å–∞') ||
      reminderTime.includes('every 3 hours')
    ) {
      return '0 */3 * * *'; // –ö–∞–∂–¥—ã–µ 3 —á–∞—Å–∞
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 4 —á–∞—Å–∞') ||
      reminderTime.includes('every 4 hours')
    ) {
      return '0 */4 * * *'; // –ö–∞–∂–¥—ã–µ 4 —á–∞—Å–∞
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤') ||
      reminderTime.includes('every 6 hours')
    ) {
      return '0 */6 * * *'; // –ö–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤
    }

    // –ü–∞—Ä—Å–∏–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, "09:00", "14:30")
    const timeMatch = reminderTime.match(/(\d{1,2}):(\d{2})/);
    if (timeMatch) {
      const [, hours, minutes] = timeMatch;
      if (frequency === 'DAILY') {
        return `${minutes} ${hours} * * *`; // –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
      }
      if (frequency === 'WEEKLY') {
        return `${minutes} ${hours} * * 1`; // –ö–∞–∂–¥—ã–π –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
      }
    }

    // –ü–∞—Ä—Å–∏–º –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –≤ –º–∏–Ω—É—Ç–∞—Ö
    if (
      reminderTime.includes('–∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É') ||
      reminderTime.includes('every minute')
    ) {
      return '* * * * *'; // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ –¥–≤–µ –º–∏–Ω—É—Ç—ã') ||
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã') ||
      reminderTime.includes('every 2 minutes')
    ) {
      return '*/2 * * * *'; // –ö–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ —Ç—Ä–∏ –º–∏–Ω—É—Ç—ã') ||
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 3 –º–∏–Ω—É—Ç—ã') ||
      reminderTime.includes('every 3 minutes')
    ) {
      return '*/3 * * * *'; // –ö–∞–∂–¥—ã–µ 3 –º–∏–Ω—É—Ç—ã
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ –ø—è—Ç—å –º–∏–Ω—É—Ç') ||
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç') ||
      reminderTime.includes('every 5 minutes')
    ) {
      return '*/5 * * * *'; // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ –¥–µ—Å—è—Ç—å –º–∏–Ω—É—Ç') ||
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç') ||
      reminderTime.includes('every 10 minutes')
    ) {
      return '*/10 * * * *'; // –ö–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç') ||
      reminderTime.includes('every 15 minutes')
    ) {
      return '*/15 * * * *'; // –ö–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç
    }

    if (
      reminderTime.includes('–∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç') ||
      reminderTime.includes('–∫–∞–∂–¥—ã–µ –ø–æ–ª—á–∞—Å–∞') ||
      reminderTime.includes('every 30 minutes')
    ) {
      return '*/30 * * * *'; // –ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
    }

    // –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –ø—Ä–∏–≤—ã—á–µ–∫ - 9 —É—Ç—Ä–∞
    if (frequency === 'DAILY') {
      return '0 9 * * *';
    }

    return null;
  }

  async sendHabitReminder(habit: any) {
    try {
      const user =
        habit.user ||
        (await this.prisma.user.findUnique({
          where: { id: habit.userId },
        }));

      if (!user) {
        this.logger.warn(`User not found for habit ${habit.id}`);
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–ø—É—Å–∫–∞ –ø—Ä–∏–≤—ã—á–∫–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
      if (
        await this.telegramBotService.isHabitSkippedToday(habit.id, user.id)
      ) {
        this.logger.log(
          `Habit ${habit.id} is skipped for today, not sending reminder`,
        );
        return;
      }

      const message = this.generateReminderMessage(habit);
      const keyboard = this.generateReminderKeyboard(habit.id);

      await this.telegramBotService.sendMessageToUser(
        parseInt(user.id),
        message,
        {
          parse_mode: 'Markdown',
          reply_markup: keyboard,
        },
      );

      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
      await this.prisma.habit.update({
        where: { id: habit.id },
        data: { updatedAt: new Date() },
      });

      this.logger.log(
        `Sent reminder for habit "${habit.title}" to user ${user.id}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to send reminder for habit ${habit.id}:`,
        error,
      );
    }
  }

  private generateReminderMessage(habit: any): string {
    const messages = {
      '–ø–∏—Ç—å –≤–æ–¥—É –∫–∞–∂–¥—ã–π —á–∞—Å': [
        'üíß –í—Ä–µ–º—è –ø–∏—Ç—å –≤–æ–¥—É! –ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ –æ –≥–∏–¥—Ä–∞—Ç–∞—Ü–∏–∏!',
        'üö∞ –ü–æ—Ä–∞ –≤—ã–ø–∏—Ç—å —Å—Ç–∞–∫–∞–Ω –≤–æ–¥—ã! –í–∞—à –æ—Ä–≥–∞–Ω–∏–∑–º —Å–∫–∞–∂–µ—Ç —Å–ø–∞—Å–∏–±–æ!',
        'üí¶ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: –≤—Ä–µ–º—è –¥–ª—è –≤–æ–¥—ã! –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –≤–æ–¥–Ω—ã–π –±–∞–ª–∞–Ω—Å!',
      ],
      '–¥–µ–ª–∞—Ç—å –∑–∞—Ä—è–¥–∫—É': [
        'üèÉ‚Äç‚ôÇÔ∏è –í—Ä–µ–º—è –¥–ª—è –∑–∞—Ä—è–¥–∫–∏! –†–∞–∑–æ–º–Ω–∏—Ç–µ —Ç–µ–ª–æ!',
        'üí™ –ü–æ—Ä–∞ –¥–µ–ª–∞—Ç—å —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è! –í–∞—à–µ —Ç–µ–ª–æ –∂–¥–µ—Ç –¥–≤–∏–∂–µ–Ω–∏—è!',
        'ü§∏‚Äç‚ôÄÔ∏è –í—Ä–µ–º—è –∑–∞—Ä—è–¥–∫–∏! –ù–µ—Å–∫–æ–ª—å–∫–æ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –ø—Ä–∏–¥–∞–¥—É—Ç –±–æ–¥—Ä–æ—Å—Ç–∏!',
      ],
      –º–µ–¥–∏—Ç–∞—Ü–∏—è: [
        'üßò‚Äç‚ôÇÔ∏è –í—Ä–µ–º—è –¥–ª—è –º–µ–¥–∏—Ç–∞—Ü–∏–∏. –ù–∞–π–¥–∏—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –¥–ª—è —Å–µ–±—è!',
        'üå∏ –ü–æ—Ä–∞ –ø–æ–º–µ–¥–∏—Ç–∏—Ä–æ–≤–∞—Ç—å! –£—Å–ø–æ–∫–æ–π—Ç–µ —É–º –∏ —Ä–∞—Å—Å–ª–∞–±—å—Ç–µ—Å—å!',
        '‚òØÔ∏è –í—Ä–µ–º—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –≥–∞—Ä–º–æ–Ω–∏–∏! –ù–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –º–µ–¥–∏—Ç–∞—Ü–∏–∏!',
      ],
    };

    // –ò—â–µ–º –ø–æ–¥—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    const habitTitle = habit.title.toLowerCase();

    for (const [key, messageList] of Object.entries(messages)) {
      if (habitTitle.includes(key)) {
        return messageList[Math.floor(Math.random() * messageList.length)];
      }
    }

    // –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    return `‚è∞ *–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –ø—Ä–∏–≤—ã—á–∫–µ*\n\nüéØ ${habit.title}\n\n–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–∏—Ç—å –≤–∞—à—É –ø—Ä–∏–≤—ã—á–∫—É!`;
  }

  private generateReminderKeyboard(habitId: string) {
    return {
      inline_keyboard: [
        [
          { text: '‚úÖ –í—ã–ø–æ–ª–Ω–∏–ª', callback_data: `complete_habit_${habitId}` },
          {
            text: '‚è∞ –û—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ 15 –º–∏–Ω',
            callback_data: `snooze_habit_${habitId}_15`,
          },
        ],
        [
          { text: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: `habit_stats_${habitId}` },
          {
            text: '‚ùå –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–µ–≥–æ–¥–Ω—è',
            callback_data: `skip_habit_${habitId}`,
          },
        ],
      ],
    };
  }

  async cancelHabitReminder(habitId: string) {
    const jobName = `habit_reminder_${habitId}`;

    if (this.activeReminders.has(jobName)) {
      const task = this.activeReminders.get(jobName);
      task?.stop();
      task?.destroy();
      this.activeReminders.delete(jobName);

      this.logger.log(`Cancelled reminder for habit ${habitId}`);
    }
  }

  async updateHabitReminder(habitId: string) {
    const habit = await this.prisma.habit.findUnique({
      where: { id: habitId },
      include: { user: true },
    });

    if (!habit) {
      return;
    }

    // –û—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    await this.cancelHabitReminder(habitId);

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ, –µ—Å–ª–∏ –ø—Ä–∏–≤—ã—á–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –∏ –µ—Å—Ç—å –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    if (habit.isActive && habit.reminderTime) {
      await this.scheduleHabitReminder(habit);
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ snooze (–æ—Ç–ª–æ–∂–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ)
  async snoozeHabitReminder(habitId: string, minutes: number) {
    const delayMs = minutes * 60 * 1000;

    setTimeout(async () => {
      const habit = await this.prisma.habit.findUnique({
        where: { id: habitId },
        include: { user: true },
      });

      if (habit) {
        await this.sendHabitReminder(habit);
      }
    }, delayMs);

    this.logger.log(`Snoozed habit ${habitId} for ${minutes} minutes`);
  }

  // Cron job –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–∞—Ä—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π (—Ä–∞–∑ –≤ –¥–µ–Ω—å)
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async cleanupOldJobs() {
    this.logger.log('Running daily cleanup of notification jobs');

    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –æ—á–∏—Å—Ç–∫–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –ø—Ä–∏–≤—ã—á–µ–∫
    const inactiveHabits = await this.prisma.habit.findMany({
      where: { isActive: false },
      select: { id: true },
    });

    for (const habit of inactiveHabits) {
      await this.cancelHabitReminder(habit.id);
    }

    this.logger.log(
      `Cleaned up ${inactiveHabits.length} inactive habit reminders`,
    );
  }

  // === DEPENDENCY SUPPORT SYSTEM ===

  // Cron job –¥–ª—è —É—Ç—Ä–µ–Ω–Ω–∏—Ö –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 9:00)
  @Cron('0 9 * * *')
  async sendMorningMotivation() {
    this.logger.log('Running morning motivation messages');

    try {
      const activeDependencies = await this.prisma.dependencySupport.findMany({
        where: { status: 'ACTIVE' },
        include: { user: true },
      });

      for (const dependency of activeDependencies) {
        try {
          const motivation = this.generateMorningMotivation(dependency.type);

          await this.telegramBotService.sendMessageToUser(
            parseInt(dependency.userId),
            `üåÖ *–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!*\n\n${motivation}\n\nüí™ –¢—ã —Å–º–æ–∂–µ—à—å —Å–ø—Ä–∞–≤–∏—Ç—å—Å—è —Å —ç—Ç–∏–º!`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    {
                      text: 'ü§ù –û–±–µ—â–∞—é —Å–∞–º —Å–µ–±–µ',
                      callback_data: `morning_promise_${dependency.type.toLowerCase()}`,
                    },
                  ],
                ],
              },
              parse_mode: 'Markdown',
            },
          );

          // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
          await this.prisma.dependencySupport.update({
            where: { id: dependency.id },
            data: { totalPromises: dependency.totalPromises + 1 },
          });
        } catch (error) {
          this.logger.error(
            `Failed to send morning message to ${dependency.userId}:`,
            error,
          );
        }
      }

      this.logger.log(
        `Sent morning messages to ${activeDependencies.length} users`,
      );
    } catch (error) {
      this.logger.error('Error in morning motivation job:', error);
    }
  }

  // Cron job –¥–ª—è –≤–µ—á–µ—Ä–Ω–∏—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫ (–∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 21:00)
  @Cron('0 21 * * *')
  async sendEveningCheck() {
    this.logger.log('Running evening check messages');

    try {
      const activeDependencies = await this.prisma.dependencySupport.findMany({
        where: { status: 'ACTIVE' },
        include: { user: true },
      });

      for (const dependency of activeDependencies) {
        try {
          const checkMessage = this.generateEveningCheck(dependency.type);

          await this.telegramBotService.sendMessageToUser(
            parseInt(dependency.userId),
            `üåô *–í—Ä–µ–º—è –ø–æ–¥–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥–∏ –¥–Ω—è*\n\n${checkMessage}\n\n‚ùì –ö–∞–∫ –ø—Ä–æ—à–µ–ª –¥–µ–Ω—å? –ü—Ä–æ–¥–µ—Ä–∂–∞–ª—Å—è?`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    {
                      text: 'üí™ –î–µ—Ä–∂—É—Å—å',
                      callback_data: `evening_success_${dependency.type.toLowerCase()}`,
                    },
                    {
                      text: 'üòî –°–¥–∞–ª—Å—è',
                      callback_data: `evening_fail_${dependency.type.toLowerCase()}`,
                    },
                  ],
                ],
              },
              parse_mode: 'Markdown',
            },
          );
        } catch (error) {
          this.logger.error(
            `Failed to send evening message to ${dependency.userId}:`,
            error,
          );
        }
      }

      this.logger.log(
        `Sent evening messages to ${activeDependencies.length} users`,
      );
    } catch (error) {
      this.logger.error('Error in evening check job:', error);
    }
  }

  private generateMorningMotivation(dependencyType: string): string {
    const motivations = {
      SMOKING: [
        'üö≠ –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –±–µ–∑ —Å–∏–≥–∞—Ä–µ—Ç - —ç—Ç–æ –¥–µ–Ω—å, –∫–æ–≥–¥–∞ —Ç—ã —Å—Ç–∞–Ω–æ–≤–∏—à—å—Å—è —Å–∏–ª—å–Ω–µ–µ',
        'üå± –¢–≤–æ—ë —Ç–µ–ª–æ —É–∂–µ –Ω–∞—á–∏–Ω–∞–µ—Ç –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å—Å—è. –ü—Ä–æ–¥–æ–ª–∂–∞–π!',
        'üí® –ö–∞–∂–¥—ã–π –≤–¥–æ—Ö —á–∏—Å—Ç–æ–≥–æ –≤–æ–∑–¥—É—Ö–∞ - —ç—Ç–æ —Ç–≤–æ—è –ø–æ–±–µ–¥–∞',
      ],
      ALCOHOL: [
        'üß† –Ø—Å–Ω–æ—Å—Ç—å –º—ã—Å–ª–∏ –∏ —ç–Ω–µ—Ä–≥–∏—è - —ç—Ç–æ —Ç–≤–æ–∏ –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ —Ç—Ä–µ–∑–≤–æ—Å—Ç—å',
        'üí™ –¢—ã –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—à—å —Å–≤–æ—é –∂–∏–∑–Ω—å, –∞ –Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å',
        'üåü –ö–∞–∂–¥—ã–π —Ç—Ä–µ–∑–≤—ã–π –¥–µ–Ω—å –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç —Ç–µ–±—è –∫ –ª—É—á—à–µ–π –≤–µ—Ä—Å–∏–∏ —Å–µ–±—è',
      ],
      DRUGS: [
        'üÜì –°–≤–æ–±–æ–¥–∞ –æ—Ç –≤–µ—â–µ—Å—Ç–≤ - —ç—Ç–æ —Å–≤–æ–±–æ–¥–∞ –±—ã—Ç—å —Å–æ–±–æ–π',
        'üßò‚Äç‚ôÇÔ∏è –¢–≤–æ–π —Ä–∞–∑—É–º —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —è—Å–Ω–µ–µ —Å –∫–∞–∂–¥—ã–º –¥–Ω–µ–º',
        'üåà –ñ–∏–∑–Ω—å –ø–æ–ª–Ω–∞ –∫—Ä–∞—Å–æ–∫, –∫–æ–≥–¥–∞ —Ç—ã –≤–∏–¥–∏—à—å –µ—ë —Ä–µ–∞–ª—å–Ω–æ–π',
      ],
      GAMING: [
        'üéØ –†–µ–∞–ª—å–Ω–∞—è –∂–∏–∑–Ω—å - —ç—Ç–æ —Ç–≤–æ—è –≥–ª–∞–≤–Ω–∞—è –∏–≥—Ä–∞',
        '‚è∞ –í—Ä–µ–º—è, –ø–æ—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –Ω–∞ —Ä–∞–∑–≤–∏—Ç–∏–µ, –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Ç–µ—Ä—è–µ—Ç—Å—è',
        'üå± –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –±–µ–∑ –∏–≥—Ä - —à–∞–≥ –∫ –Ω–æ–≤—ã–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è–º',
      ],
      SOCIAL_MEDIA: [
        'üì± –†–µ–∞–ª—å–Ω—ã–π –º–∏—Ä –Ω–∞–º–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ',
        'üë• –ñ–∏–≤–æ–µ –æ–±—â–µ–Ω–∏–µ –¥–∞–µ—Ç —ç–Ω–µ—Ä–≥–∏—é, –∫–æ—Ç–æ—Ä—É—é –Ω–µ –¥–∞—Å—Ç —ç–∫—Ä–∞–Ω',
        'üßò‚Äç‚ôÄÔ∏è –ü–æ–∫–æ–π —É–º–∞ –ø—Ä–∏—Ö–æ–¥–∏—Ç —Å –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ–º –æ—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏',
      ],
    };

    const typeMotivations = motivations[dependencyType] || motivations.SMOKING;
    return typeMotivations[Math.floor(Math.random() * typeMotivations.length)];
  }

  private generateEveningCheck(dependencyType: string): string {
    const checks = {
      SMOKING: 'üö≠ –ö–∞–∫ –¥–µ–ª–∞ —Å –æ—Ç–∫–∞–∑–æ–º –æ—Ç –∫—É—Ä–µ–Ω–∏—è?',
      ALCOHOL: 'üç∑ –ö–∞–∫ –ø—Ä–æ—à–µ–ª –¥–µ–Ω—å –±–µ–∑ –∞–ª–∫–æ–≥–æ–ª—è?',
      DRUGS: 'üíä –£–¥–∞–ª–æ—Å—å –ª–∏ –∏–∑–±–µ–∂–∞—Ç—å —É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è?',
      GAMING: 'üéÆ –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞–ª –ª–∏ –≤—Ä–µ–º—è –∑–∞ –∏–≥—Ä–∞–º–∏?',
      SOCIAL_MEDIA: 'üì± –ö–∞–∫ –¥–µ–ª–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Å–æ—Ü—Å–µ—Ç–µ–π?',
    };

    return checks[dependencyType] || checks.SMOKING;
  }
}
